# 🚀 RISC-V内核调试器 - 时间旅行BPF调试器 (Time Travel Debugger)

基于BPF技术实现的RISC-V内核时间旅行调试器，支持断点录制、回放和时间线导航的TUI工具。

## ✨ 核心特性

### 🎯 时间旅行调试 (Time Travel Debugging)
- **调试帧录制**: 实时捕获每个断点触发时的完整系统状态
- **时间线回放**: 在任意调试帧之间跳转，实现时间旅行效果
- **会话持久化**: 调试会话保存为`.frames`文件，支持离线分析

### 🔍 BPF深度集成
- **动态BPF程序生成**: 根据断点自动生成针对性的BPF代码
- **RISC-V寄存器捕获**: 完整记录PC、RA、SP、GP、TP等所有寄存器状态
- **栈数据采集**: 实时捕获栈内存和局部变量信息
- **函数调用链跟踪**: 记录函数调用关系和参数传递

### 🖥️ 先进的TUI界面
- **多面板布局**: 代码、寄存器、变量、堆栈、文件浏览器等多窗口协同
- **动态布局调整**: 拖拽调整窗口大小，全屏切换，自适应布局
- **实时数据展示**: 寄存器、变量、堆栈数据实时更新
- **时间线导航**: F9/F10快速在调试帧间跳转

## 🛠️ 工作模式

### 1. 🔴 录制模式 (Recording Mode)
启动实时调试录制，每个断点触发都会自动保存为一个调试帧：
```bash
start-recording        # 开始录制调试会话
stop-recording         # 停止录制并自动保存
```

### 2. ⏸️ 回放模式 (Playback Mode)  
加载历史调试会话，支持时间旅行：
```bash
load-session debug_session_20240101_120000.frames  # 加载会话文件
jump-frame 15          # 跳转到第15帧
next-frame            # 下一帧 (或按F10)
prev-frame            # 上一帧 (或按F9)
```

### 3. 🔄 实时模式 (Live Mode)
传统的实时调试模式，支持设置断点和BPF程序生成。

## 📋 使用工作流程

### Step 1: 项目设置
```bash
./main /path/to/your/kernel/project
```

### Step 2: 设置断点
- 在代码视图中按Enter键设置/取消断点
- 支持函数级断点，自动解析函数名

### Step 3: 生成BPF程序  
```bash
generate-bpf          # 根据断点生成BPF代码
compile-bpf           # 编译BPF程序
```

### Step 4: 开始时间旅行调试
```bash
start-recording       # 开始录制调试会话
# ... 触发断点，自动记录调试帧 ...
stop-recording        # 停止录制，自动保存为.frames文件
```

### Step 5: 时间旅行分析
```bash
load-session latest_session.frames  # 加载调试会话
jump-frame 0          # 跳转到第一帧
# 使用F9/F10在帧间导航，分析程序执行轨迹
```

## ⌨️ 快捷键说明

### 全局快捷键
- `F1-F6`: 快速切换到对应窗口
- `F9`: 上一帧 (时间后退)
- `F10`: 下一帧 (时间前进) 
- `F11`: 全屏切换
- `Tab`: 循环切换窗口
- `Ctrl+C`: 退出程序

### 调试操作
- `Enter` (代码视图): 设置/取消断点
- `g`: 生成BPF程序
- `c`: 清除所有断点
- `Ctrl+F`: 搜索代码

### 布局调整
- `Ctrl+R`: 重置布局
- `Ctrl+J/K`: 调整命令窗口高度
- `Ctrl+H/L`: 调整左侧面板宽度

## 🎮 命令系统

### 断点管理
```bash
break <file> <line>     # 设置断点
clear-breakpoints       # 清除所有断点
list-breakpoints        # 列出断点
```

### BPF操作
```bash
generate-bpf           # 生成BPF程序
compile-bpf            # 编译BPF程序
load-bpf               # 加载BPF程序到内核
unload-bpf             # 卸载BPF程序
```

### 录制回放
```bash
start-recording        # 开始录制
stop-recording         # 停止录制
load-session <file>    # 加载调试会话
save-session <file>    # 保存调试会话
list-sessions          # 列出可用会话
```

### 帧导航
```bash
jump-frame <index>     # 跳转到指定帧
next-frame            # 下一帧
prev-frame            # 上一帧
frame-info            # 显示当前帧信息
show-timeline         # 切换时间线视图
```

## 🗂️ 文件结构

```
project/
├── main.go                    # 主程序
├── enhanced_bpf_template.c    # BPF程序模板
├── Makefile                   # 构建脚本
├── debug.c                    # 生成的BPF程序
├── debug.o                    # 编译的BPF对象文件
├── *.frames                   # 调试会话文件
└── .debug_breakpoints.json    # 断点持久化文件
```

## 🔧 技术架构

### BPF集成层
- **动态程序生成**: 根据断点列表生成定制化BPF代码
- **环形缓冲区**: 高效的内核-用户空间数据传输
- **事件过滤**: 只捕获关心的断点事件，降低开销

### 调试帧系统
- **帧数据结构**: 包含寄存器、变量、栈、调用链的完整快照
- **增量存储**: 优化存储空间，只记录变化的部分
- **索引机制**: 快速定位和跳转到任意帧

### TUI渲染引擎
- **多窗口管理**: 独立的窗口生命周期和事件处理
- **实时数据绑定**: 数据变化自动触发界面更新
- **响应式布局**: 根据终端大小自动调整布局

## 🧪 演示场景

### 场景1：内核函数调用追踪
1. 在关键内核函数设置断点
2. 启动录制模式
3. 触发内核操作（如系统调用）
4. 停止录制，获得完整的函数调用轨迹
5. 回放分析，查看每次函数调用的参数和寄存器状态

### 场景2：并发bug调试
1. 在多个相关函数设置断点
2. 录制并发操作过程
3. 时间旅行回放，分析竞态条件
4. 跳转到关键时间点，检查共享变量状态

### 场景3：性能热点分析
1. 在疑似性能瓶颈处设置断点
2. 录制性能敏感操作
3. 分析调用频率和执行时间
4. 定位性能热点和优化方向

## 🚀 扩展特性

### 高级调试功能
- **条件断点**: 支持基于寄存器值的条件触发
- **数据断点**: 监控内存区域的读写操作
- **时间线搜索**: 在历史帧中搜索特定状态

### 协作功能
- **会话分享**: 导出调试会话供团队分析
- **注释系统**: 在调试帧中添加分析注释
- **报告生成**: 自动生成调试分析报告

## 💡 使用技巧

1. **合理设置断点**: 避免在高频函数设置断点，影响系统性能
2. **分段录制**: 针对特定问题分段录制，便于分析
3. **利用时间线**: 使用F9/F10快速定位问题时间点
4. **组合分析**: 结合寄存器、变量、堆栈多维度分析
5. **会话管理**: 为不同问题建立独立的调试会话

## 🔮 未来发展

- **AI辅助分析**: 基于历史调试数据进行智能分析
- **可视化增强**: 3D调用图、数据流图等可视化展示  
- **远程调试**: 支持网络环境下的远程内核调试
- **多架构支持**: 扩展到ARM64、x86等其他架构

---

🎯 **这是一个革命性的内核调试工具，让时间旅行调试成为现实！**
