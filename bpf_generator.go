package main

import (
	"fmt"
	"strings"
	"path/filepath"
	"io/ioutil"
)

// ========== BPF代码生成器 ==========

type BPFCodeGenerator struct {
	ctx *DebuggerContext
}

// NewBPFCodeGenerator 创建BPF代码生成器
func NewBPFCodeGenerator(ctx *DebuggerContext) *BPFCodeGenerator {
	return &BPFCodeGenerator{ctx: ctx}
}

// ========== BPF程序生成 ==========

// GenerateBPFProgram 根据断点配置生成BPF程序
func (bcg *BPFCodeGenerator) GenerateBPFProgram() (string, error) {
	if bcg.ctx.Project == nil {
		return "", fmt.Errorf("项目未打开")
	}
	
	if len(bcg.ctx.Project.Breakpoints) == 0 {
		return "", fmt.Errorf("未设置断点")
	}
	
	// 生成BPF程序头部
	code := bcg.generateBPFHeader()
	
	// 生成数据结构定义
	code += bcg.generateDataStructures()
	
	// 生成映射定义
	code += bcg.generateMaps()
	
	// 生成辅助函数
	code += bcg.generateHelperFunctions()
	
	// 为每个断点生成kprobe函数
	for i, bp := range bcg.ctx.Project.Breakpoints {
		if bp.Enabled && bp.Function != "" {
			code += bcg.generateKprobeFunction(bp, i)
		}
	}
	
	return code, nil
}

// generateBPFHeader 生成BPF程序头部
func (bcg *BPFCodeGenerator) generateBPFHeader() string {
	return `// Generated BPF program for RISC-V kernel debugging
// Auto-generated by kernel_driver_debug_tui

#include <linux/bpf.h>
#include <linux/ptrace.h>
#include <linux/sched.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

// RISC-V架构定义
#ifndef __riscv
#define __riscv 1
#endif

// 架构相关寄存器定义
#ifdef __riscv
struct riscv_pt_regs {
    unsigned long pc;
    unsigned long ra;
    unsigned long sp;
    unsigned long gp;
    unsigned long tp;
    unsigned long t0;
    unsigned long t1;
    unsigned long t2;
    unsigned long s0;
    unsigned long s1;
    unsigned long a0;
    unsigned long a1;
    unsigned long a2;
    unsigned long a3;
    unsigned long a4;
    unsigned long a5;
    unsigned long a6;
    unsigned long a7;
    // 其他寄存器...
};
#endif

`
}

// generateDataStructures 生成数据结构定义
func (bcg *BPFCodeGenerator) generateDataStructures() string {
	return `// 调试事件数据结构（与Go代码中的BPFDebugEvent完全匹配）
struct debug_event {
    __u32 pid;
    __u32 tgid;
    __u64 timestamp;
    __u32 breakpoint_id;
    char comm[16];
    char function[64];
    
    // RISC-V寄存器状态
    __u64 pc, ra, sp, gp, tp;
    __u64 t0, t1, t2;
    __u64 s0, s1;
    __u64 a0, a1, a2, a3, a4, a5, a6, a7;
    
    // 栈数据和局部变量
    __u64 stack_data[8];
    __u64 local_vars[16];
};

// 控制结构
struct debug_control {
    __u32 enabled;
    __u32 breakpoint_mask;
    __u64 filter_pid;
};

`
}

// generateMaps 生成BPF映射定义
func (bcg *BPFCodeGenerator) generateMaps() string {
	return `// BPF映射定义

// 事件环形缓冲区，用于向用户空间发送调试事件
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024);
} events SEC(".maps");

// 控制映射，用于运行时配置
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 1);
    __type(key, __u32);
    __type(value, struct debug_control);
} control SEC(".maps");

// 断点计数映射
struct {
    __uint(type, BPF_MAP_TYPE_ARRAY);
    __uint(max_entries, 32);
    __type(key, __u32);
    __type(value, __u64);
} breakpoint_counters SEC(".maps");

`
}

// generateHelperFunctions 生成辅助函数
func (bcg *BPFCodeGenerator) generateHelperFunctions() string {
	return `// 辅助函数

// 读取RISC-V寄存器
static __always_inline void read_riscv_registers(struct pt_regs *regs, struct debug_event *event)
{
#ifdef __riscv
    // 直接从pt_regs读取RISC-V寄存器
    event->pc = PT_REGS_IP(regs);
    event->ra = regs->ra;
    event->sp = PT_REGS_SP(regs);
    event->gp = regs->gp;
    event->tp = regs->tp;
    event->t0 = regs->t0;
    event->t1 = regs->t1;
    event->t2 = regs->t2;
    event->s0 = regs->s0;
    event->s1 = regs->s1;
    event->a0 = PT_REGS_PARM1(regs);
    event->a1 = PT_REGS_PARM2(regs);
    event->a2 = PT_REGS_PARM3(regs);
    event->a3 = PT_REGS_PARM4(regs);
    event->a4 = PT_REGS_PARM5(regs);
    event->a5 = PT_REGS_PARM6(regs);
    event->a6 = regs->a6;
    event->a7 = regs->a7;
#else
    // 其他架构的适配代码
    event->pc = PT_REGS_IP(regs);
    event->sp = PT_REGS_SP(regs);
    event->a0 = PT_REGS_PARM1(regs);
    // ... 设置默认值
#endif
}

// 读取栈数据
static __always_inline void read_stack_data(struct pt_regs *regs, struct debug_event *event)
{
    void *stack_ptr = (void *)PT_REGS_SP(regs);
    
    // 安全地读取栈数据
    for (int i = 0; i < 8; i++) {
        long ret = bpf_probe_read_kernel(&event->stack_data[i], 
                                        sizeof(__u64), 
                                        stack_ptr + (i * sizeof(__u64)));
        if (ret < 0) {
            event->stack_data[i] = 0;
        }
    }
}

// 尝试读取局部变量（基于栈帧指针）
static __always_inline void read_local_variables(struct pt_regs *regs, struct debug_event *event)
{
#ifdef __riscv
    void *frame_ptr = (void *)regs->s0; // s0是RISC-V的帧指针
#else
    void *frame_ptr = (void *)PT_REGS_FP(regs);
#endif
    
    // 尝试读取帧指针附近的数据作为局部变量
    for (int i = 0; i < 16; i++) {
        long ret = bpf_probe_read_kernel(&event->local_vars[i], 
                                        sizeof(__u64), 
                                        frame_ptr - ((i + 1) * sizeof(__u64)));
        if (ret < 0) {
            event->local_vars[i] = 0;
        }
    }
}

// 检查调试控制状态
static __always_inline int is_debugging_enabled(__u32 breakpoint_id)
{
    __u32 key = 0;
    struct debug_control *ctrl = bpf_map_lookup_elem(&control, &key);
    
    if (!ctrl || !ctrl->enabled) {
        return 0;
    }
    
    // 检查断点掩码
    if (ctrl->breakpoint_mask && !(ctrl->breakpoint_mask & (1 << breakpoint_id))) {
        return 0;
    }
    
    // 检查PID过滤
    if (ctrl->filter_pid && ctrl->filter_pid != bpf_get_current_pid_tgid() >> 32) {
        return 0;
    }
    
    return 1;
}

// 发送调试事件
static __always_inline void send_debug_event(struct pt_regs *regs, 
                                            const char *function_name, 
                                            __u32 breakpoint_id)
{
    // 检查是否启用调试
    if (!is_debugging_enabled(breakpoint_id)) {
        return;
    }
    
    // 分配事件结构
    struct debug_event *event = bpf_ringbuf_reserve(&events, sizeof(*event), 0);
    if (!event) {
        return;
    }
    
    // 填充基本信息
    __u64 pid_tgid = bpf_get_current_pid_tgid();
    event->pid = pid_tgid >> 32;
    event->tgid = pid_tgid;
    event->timestamp = bpf_ktime_get_ns();
    event->breakpoint_id = breakpoint_id;
    
    // 获取进程名
    bpf_get_current_comm(event->comm, sizeof(event->comm));
    
    // 设置函数名
    __builtin_memcpy(event->function, function_name, sizeof(event->function));
    
    // 读取寄存器状态
    read_riscv_registers(regs, event);
    
    // 读取栈数据
    read_stack_data(regs, event);
    
    // 读取局部变量
    read_local_variables(regs, event);
    
    // 更新断点计数
    __u32 counter_key = breakpoint_id;
    __u64 *counter = bpf_map_lookup_elem(&breakpoint_counters, &counter_key);
    if (counter) {
        (*counter)++;
    }
    
    // 提交事件
    bpf_ringbuf_submit(event, 0);
}

`
}

// generateKprobeFunction 为指定断点生成kprobe函数
func (bcg *BPFCodeGenerator) generateKprobeFunction(bp Breakpoint, index int) string {
	functionName := strings.ReplaceAll(bp.Function, ".", "_")
	functionName = strings.ReplaceAll(functionName, "-", "_")
	
	return fmt.Sprintf(`// 断点 %d: %s
SEC("kprobe/%s")
int trace_%s(struct pt_regs *regs)
{
    send_debug_event(regs, "%s", %d);
    return 0;
}

`, index+1, bp.Function, bp.Function, functionName, bp.Function, index)
}

// ========== 文件操作 ==========

// SaveBPFProgram 保存生成的BPF程序到文件
func (bcg *BPFCodeGenerator) SaveBPFProgram(filename string) error {
	code, err := bcg.GenerateBPFProgram()
	if err != nil {
		return err
	}
	
	// 确定保存路径
	var fullPath string
	if bcg.ctx.Project != nil {
		fullPath = filepath.Join(bcg.ctx.Project.RootPath, filename)
	} else {
		fullPath = filename
	}
	
	// 写入文件
	err = ioutil.WriteFile(fullPath, []byte(code), 0644)
	if err != nil {
		return fmt.Errorf("保存BPF程序失败: %v", err)
	}
	
	return nil
}

// GenerateAndSaveBPFProgram 生成并保存BPF程序
func (bcg *BPFCodeGenerator) GenerateAndSaveBPFProgram() error {
	return bcg.SaveBPFProgram("generated_debug.bpf.c")
}

// ========== 代码分析和验证 ==========

// ValidateBreakpoints 验证断点配置
func (bcg *BPFCodeGenerator) ValidateBreakpoints() []string {
	var issues []string
	
	if bcg.ctx.Project == nil {
		issues = append(issues, "❌ 项目未打开")
		return issues
	}
	
	if len(bcg.ctx.Project.Breakpoints) == 0 {
		issues = append(issues, "❌ 未设置任何断点")
		return issues
	}
	
	for i, bp := range bcg.ctx.Project.Breakpoints {
		if bp.Function == "" {
			issues = append(issues, fmt.Sprintf("⚠️  断点 %d 缺少函数名", i+1))
			continue
		}
		
		if !bp.Enabled {
			issues = append(issues, fmt.Sprintf("ℹ️  断点 %d (%s) 已禁用", i+1, bp.Function))
			continue
		}
		
		// 检查函数名合法性
		if strings.Contains(bp.Function, " ") {
			issues = append(issues, fmt.Sprintf("⚠️  断点 %d 函数名包含空格: %s", i+1, bp.Function))
		}
		
		issues = append(issues, fmt.Sprintf("✅ 断点 %d: %s", i+1, bp.Function))
	}
	
	return issues
}

// GetGeneratedCodeInfo 获取生成的代码信息
func (bcg *BPFCodeGenerator) GetGeneratedCodeInfo() map[string]interface{} {
	info := make(map[string]interface{})
	
	if bcg.ctx.Project == nil {
		info["error"] = "项目未打开"
		return info
	}
	
	enabledBreakpoints := 0
	var functions []string
	
	for _, bp := range bcg.ctx.Project.Breakpoints {
		if bp.Enabled && bp.Function != "" {
			enabledBreakpoints++
			functions = append(functions, bp.Function)
		}
	}
	
	info["total_breakpoints"] = len(bcg.ctx.Project.Breakpoints)
	info["enabled_breakpoints"] = enabledBreakpoints
	info["target_functions"] = functions
	info["architecture"] = "RISC-V"
	info["output_file"] = "generated_debug.bpf.c"
	
	if enabledBreakpoints > 0 {
		info["status"] = "ready"
	} else {
		info["status"] = "no_targets"
	}
	
	return info
}

// PreviewBPFCode 预览生成的BPF代码（前几行）
func (bcg *BPFCodeGenerator) PreviewBPFCode(lines int) ([]string, error) {
	code, err := bcg.GenerateBPFProgram()
	if err != nil {
		return nil, err
	}
	
	codeLines := strings.Split(code, "\n")
	
	if lines > len(codeLines) {
		lines = len(codeLines)
	}
	
	return codeLines[:lines], nil
}

 